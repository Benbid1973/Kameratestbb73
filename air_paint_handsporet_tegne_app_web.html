<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Air Paint – håndsporet tegne-app</title>
  <style>
    :root { --ui: 14px/1.3 Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    html, body { margin:0; height:100%; background:#0b0c10; color:#fff; font: var(--ui); }
    #stage { position:relative; width:100%; height:100%; overflow:hidden; }
    video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); filter: saturate(0.9) brightness(0.95); }
    canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
    .panel { position: fixed; right: 12px; top: 12px; background: rgba(20,22,26,.72); backdrop-filter: blur(8px); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; min-width:210px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .panel h3{ margin:0 0 8px 0; font-size:12px; font-weight:600; opacity:.9; letter-spacing:.03em; }
    .row{ display:grid; grid-template-columns: 1fr auto; align-items:center; gap:8px; margin:8px 0; }
    .row input[type="range"]{ width:140px; }
    .swatch{ display:flex; gap:6px; flex-wrap:wrap; }
    .color{ width:18px; height:18px; border-radius:50%; border:1px solid rgba(255,255,255,.25); cursor:pointer; }
    .badge { position: fixed; left: 50%; top: 8px; transform: translateX(-50%); background: rgba(32,34,40,.8); border:1px solid rgba(255,255,255,.1); border-radius:999px; padding:6px 10px; font-size:12px; }
    .pill { display:inline-block; padding:.2em .55em; border-radius:999px; background:#ffd400; color:#242424; font-weight:700; }
    .help { position: fixed; left: 50%; bottom: 10px; transform: translateX(-50%); text-align:center; font-size:12px; opacity:.9; background: rgba(20,22,26,.65); border:1px solid rgba(255,255,255,.07); border-radius:10px; padding:8px 10px; }
    .kbd{ padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); }
    .hidden{ display:none; }
    .dot { position:fixed; width:10px; height:10px; background: #fff; border-radius:50%; transform: translate(-50%, -50%); pointer-events:none; mix-blend-mode:difference; }
    .toast{ position: fixed; left: 12px; bottom: 12px; padding:8px 10px; background: rgba(20,22,26,.8); border:1px solid rgba(255,255,255,.1); border-radius:10px; font-size:12px; opacity:0; transform: translateY(8px); transition:.3s ease; }
    .toast.show{ opacity:1; transform: translateY(0); }
  </style>
  <!-- MediaPipe Hands (classic) + utils via jsDelivr CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
  <div id="stage">
    <video id="video" playsinline></video>
    <canvas id="paint"></canvas>
    <canvas id="debug"></canvas>
  </div>

  <div class="panel" id="ui">
    <h3>Air Paint</h3>
    <div class="row"><label>Børste</label><input id="brush" type="range" min="2" max="80" value="18"></div>
    <div class="row"><label>Opacity</label><input id="alpha" type="range" min="0" max="1" step="0.01" value="1"></div>
    <div class="row"><label>Smoothing</label><input id="smooth" type="range" min="0" max="0.9" step="0.01" value="0.35"></div>
    <div class="row" style="grid-template-columns: 1fr;">
      <div class="swatch" id="swatch"></div>
    </div>
    <div class="row" style="grid-template-columns: 1fr 1fr; gap:6px;">
      <button id="undo">↶ Undo</button>
      <button id="redo">↷ Redo</button>
      <button id="save" style="grid-column: span 2;">Gem PNG</button>
      <button id="clear" style="grid-column: span 2;">Ryd</button>
    </div>
  </div>

  <div class="badge" id="modeBadge">Hold <span class="pill">pinch</span> for at tegne</div>
  <div class="help">
    Håndtegn: Åben hånd ⇒ palette • Næve ⇒ luk • Pinch ⇒ tegn • To pinches ⇒ ændr børste (afstand) • <span class="kbd">Z</span>/<span class="kbd">Y</span> undo/redo • <span class="kbd">C</span> ryd
  </div>
  <div id="cursor" class="dot hidden"></div>
  <div id="toast" class="toast"></div>

  <script>
  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const paint = $('#paint');
  const debug = $('#debug');
  const video = $('#video');
  const cursorDot = $('#cursor');
  const badge = $('#modeBadge');
  const toast = $('#toast');

  const ctx = paint.getContext('2d');
  const dtx = debug.getContext('2d');
  let W = 1280, H = 720; // will be resized to window

  const colors = ['#ffd400','#ff7a00','#ff2d55','#e6007a','#7b61ff','#00c2ff','#34c759','#00d98b','#ffffff','#111111'];
  const swatch = $('#swatch');
  let brushColor = colors[0];
  let brushSize = parseInt($('#brush').value, 10);
  let alpha = parseFloat($('#alpha').value);
  let smooth = parseFloat($('#smooth').value);

  colors.forEach(c=>{ const el=document.createElement('button'); el.className='color'; el.style.background=c; el.title=c; el.onclick=()=>{ brushColor=c; ping(`Farve: ${c}`)}; swatch.appendChild(el); });

  $('#brush').oninput = (e)=> brushSize = parseInt(e.target.value,10);
  $('#alpha').oninput = (e)=> alpha = parseFloat(e.target.value);
  $('#smooth').oninput = (e)=> smooth = parseFloat(e.target.value);
  $('#save').onclick = savePNG;
  $('#clear').onclick = clearAll;
  $('#undo').onclick = undo;
  $('#redo').onclick = redo;

  function ping(msg){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 900); }

  function resize(){
    W = window.innerWidth; H = window.innerHeight;
    [paint, debug].forEach(c=>{ c.width = W; c.height = H; });
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- Drawing state ----------
  // Each stroke: { points:[{x,y}], size, color, alpha }
  const history = []; let redoStack = [];
  let activeStroke = null;

  function startStroke(x,y){ activeStroke = { points:[{x,y}], size: brushSize, color: brushColor, alpha }; cursorDot.classList.remove('hidden'); }
  function addPoint(x,y){ if(!activeStroke) return; const last = activeStroke.points[activeStroke.points.length-1]; const k = smooth; const nx = last? last.x + (x-last.x)*(1-k):x; const ny = last? last.y + (y-last.y)*(1-k):y; activeStroke.points.push({x:nx,y:ny}); drawLive(); moveCursor(nx,ny,activeStroke.size); }
  function endStroke(){ if(!activeStroke) return; history.push(activeStroke); redoStack=[]; activeStroke=null; drawAll(); cursorDot.classList.add('hidden'); }

  function moveCursor(x,y,size){ cursorDot.style.left=x+'px'; cursorDot.style.top=y+'px'; cursorDot.style.width = size+'px'; cursorDot.style.height = size+'px'; }

  function drawLive(){ drawAll(); if(!activeStroke) return; drawStroke(activeStroke); }
  function drawAll(){ ctx.clearRect(0,0,W,H); history.forEach(drawStroke); }
  function drawStroke(s){ if(s.points.length<2) return; ctx.save(); ctx.globalAlpha = s.alpha; ctx.strokeStyle = s.color; ctx.lineWidth = s.size; ctx.lineJoin = 'round'; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(s.points[0].x, s.points[0].y); for(let i=1;i<s.points.length;i++){ const p=s.points[i]; ctx.lineTo(p.x,p.y);} ctx.stroke(); ctx.restore(); }

  function clearAll(){ history.length = 0; redoStack = []; ctx.clearRect(0,0,W,H); ping('Lærred ryddet'); }
  function undo(){ if(history.length){ redoStack.push(history.pop()); drawAll(); ping('Undo'); } }
  function redo(){ if(redoStack.length){ history.push(redoStack.pop()); drawAll(); ping('Redo'); } }
  function savePNG(){ const a=document.createElement('a'); const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H; const tctx=tmp.getContext('2d'); tctx.drawImage(video,0,0,W,H); tctx.drawImage(paint,0,0); a.href = tmp.toDataURL('image/png'); a.download = 'air-paint.png'; a.click(); ping('Gemte PNG'); }

  document.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='z') undo();
    if(e.key.toLowerCase()==='y') redo();
    if(e.key.toLowerCase()==='c') clearAll();
  });

  // ---------- Hand tracking & gestures ----------
  // MediaPipe landmark indices: thumb tip 4, index tip 8, middle 12, ring 16, pinky 20
  let lastPinchDistBoth = null; // for two-hand brush resize
  let drawing = false;

  function normToScreen(x,y){ return { x: (1-x)*W, y: y*H }; } // mirror X to match camera

  function isPinching(lm){
    const t = lm[4], i = lm[8];
    const dx = t.x - i.x, dy = t.y - i.y; const d = Math.hypot(dx,dy);
    return d < 0.05; // threshold in normalized coords
  }
  function fingersUp(lm){ // naive: compare tip to pip distance from wrist
    const ids = [[8,6],[12,10],[16,14],[20,18]]; // index..pinky
    let up=0; for(const [tip,pip] of ids){ if(lm[tip].y < lm[pip].y) up++; } return up; }

  function onResults(res){ // res is from MediaPipe
    dtx.clearRect(0,0,W,H);
    const hands = res.multiHandLandmarks || [];

    // Draw debug skeleton
    for(const lm of hands){
      const pts = lm.map(p=>normToScreen(p.x,p.y));
      dtx.save(); dtx.strokeStyle='rgba(0,255,200,.8)'; dtx.fillStyle='rgba(255,0,128,.9)'; dtx.lineWidth=2;
      // simple bones
      const chains=[[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20]];
      chains.forEach(ch=>{ dtx.beginPath(); dtx.moveTo(pts[ch[0]].x,pts[ch[0]].y); for(let k=1;k<ch.length;k++){ dtx.lineTo(pts[ch[k]].x,pts[ch[k]].y);} dtx.stroke(); });
      pts.forEach(p=>{ dtx.beginPath(); dtx.arc(p.x,p.y,3,0,Math.PI*2); dtx.fill(); });
      dtx.restore();
    }

    // Gesture logic
    const left = hands.find((_,i)=> res.multiHandedness?.[i]?.label === 'Left');
    const right = hands.find((_,i)=> res.multiHandedness?.[i]?.label === 'Right');

    // Palette show/hide
    for(const lm of hands){
      const up = fingersUp(lm);
      if(up >= 4){ $('#ui').classList.remove('hidden'); badge.textContent='Palette åben'; }
      if(up === 0 && !isPinching(lm)) { $('#ui').classList.add('hidden'); badge.textContent='Palette lukket'; }
    }

    // Two-hand brush resize when both pinching
    if(left && right && isPinching(left) && isPinching(right)){
      const a = left[8], b = right[8];
      const d = Math.hypot(a.x-b.x, a.y-b.y);
      if(lastPinchDistBoth==null) lastPinchDistBoth = d;
      const delta = d - lastPinchDistBoth;
      brushSize = Math.min(80, Math.max(2, brushSize + delta*400));
      $('#brush').value = Math.round(brushSize);
      badge.textContent = 'Justerer børstestørrelse';
    } else { lastPinchDistBoth = null; }

    // Single-hand drawing with pinch
    let anyPinch = false;
    for(const lm of hands){
      const pinch = isPinching(lm);
      if(pinch){ anyPinch = true; const p = normToScreen(lm[8].x, lm[8].y); if(!drawing){ startStroke(p.x,p.y); drawing = true; badge.textContent='Tegner…'; } else { addPoint(p.x,p.y); } }
    }
    if(!anyPinch && drawing){ endStroke(); drawing = false; badge.textContent='Hold pinch for at tegne'; }
  }

  // ---------- Camera / MediaPipe setup ----------
  async function main(){
    const hands = new Hands({locateFile: (file)=> `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
      maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cam = new Camera(video, { 
      onFrame: async ()=>{ await hands.send({image: video}); },
      width: 1280, height: 720
    });
    await cam.start();
  }
  main();
  </script>
</body>
</html>
